Post Title: [P] S2ID: Scale Invariant Image Diffuser - trained on standard MNIST, generates 1024x1024 digits and at arbitrary aspect ratios with almost no artifacts at 6.1M parameters (Drastic code change and architectural improvement)
Author: Tripel_Meow
Score: 47
URL: https://www.reddit.com/r/MachineLearning/comments/1pwd8su/p_s2id_scale_invariant_image_diffuser_trained_on/
Number of comments: 17
Created UTC: 1766778691.0

Post Content:
^(This is an update to the previous post which can be found) [^(here)](https://www.reddit.com/r/MachineLearning/comments/1puosfp/p_siid_a_scale_invariant_pixelspace_diffusion/?utm_source=share&amp;utm_medium=web3x&amp;utm_name=web3xcss&amp;utm_term=1&amp;utm_content=share_button)^(. Take a look if you want the full context, but it's not necessary as a fair amount of things have been changed and improved. The GitHub repository can be found) [^(here)](https://github.com/Yegor-men/scale-invariant-image-diffuser)^(. Once again, forgive for the minimal readme, unclean train/inference code, as well as the usage of .pt and not .safetensors modelfiles. The focus of this post is on the architecture of the model.)

# Preface

Hello everyone.

Over the past couple weeks/months, annoyed by a couple pitfalls in classic diffusion architecures, I've been working on my own architecture, aptly named **S2ID: Scale Invariant Image Diffuser**. S2ID aims to avoid the major pitfalls found in standard diffusion architectures. Namely:

* UNet style models heavily rely on convolution kernels, and convolution kernels train to a certain pixel density. If you change your pixel density, by upscaling the image for example, the feature detectors residing in the kernels no longer work, as they are now of a different size. This is why for models like SDXL, changing the resolution at which the model generates can easily create doubling artifacts.
* DiT style models would treat the new pixels produced by upscaling as if they were actually new and appended to the edges of the image. RoPE helps generalize, but is there really a guarantee that the model knows how to "compress" context length back down to the actual size?

Fundamentally, it boils down to this: **Tokens in LLMs are atomic, pixels are not, the resolution (pixel density) doesn't affect the amount of information present, it simply changes the quality of the information**. Think of it this way: when your phone takes a 12mp photo, or a 48mp photo, or a 108mp photo, does the actual composition change? Do you treat the higher resolution image as if it had suddenly gained much more information? Not really. Same here: resolution is not a key factor. Resolution, or more importantly, pixel density, doesn't change the underlying function of the data. Hence, the goal of S2ID is to learn the underlying function, ignoring the "view" we have of it that's defined by the aspect ratio and image size. Thus, S2ID is tested to generalize on **varying image sizes and varying aspect ratios**. In the current iteration, **no image augmentation** was used during training, making the results all the more impressive.

As a side "challenge", S2ID is trained locally on my RTX 5080 and I do not intend to move to a server GPU unless absolutely necessary. The current iteration was trained in 20 epochs, batch size 25, AdamW with cosine scheduler with 2400 warmup steps going from 0 to 1e-3, and then decaying down to 1e-5. S2ID is an EMA model with 0.9995 decay (dummy text encoder is not EMA). VRAM consumption was at 12.5 GiB throughout training, total training took about 3 hours, although each epoch was trained in about 6m20s, the rest of the time was spent on intermediate diffusion and the test dataset. As said in the title, the parameter count is 6.1M, although I'm certain that it can be reduced more as in (super duper) early testing months ago I was able to get barely recognizable digits at around 2M, although that was very challenging.

# Model showcase

For the sake of the showcase, it's critical to understand that **the model was trained on standard 28x28 MNIST images** ***without any augmentations***. The only augmentation used is the coordinate jitter (explained further later on), but I would argue that this is a core component of the architecture itself, not an augmentation to the images, as it is the backbone behind what allows the model to scale well beyond the training data and why it is that it learns the continuous function in the first place and doesn't just memorize coordinates like it did last time.

Let us start with the elephant in the room, and that is the 1MP SDXL-esque generation. 1024 by 1024 images of the digits. Unfortunately, with the current implementation (issues and solutions described later) I'm hitting OOM for batch size of 10, so I'm forced to render one at a time and crappily combine them together in google sheets:

[Grid of numbers, each one diffused at 1024x1024](https://preview.redd.it/65ssouxyrl9g1.png?width=665&amp;format=png&amp;auto=webp&amp;s=3348324b64bf7b830fd87db998a27b66c2007629)

As you can see, very clean digits. In fact, the model actually seems to have an easier time diffusing at larger resolutions, there's less artifacts, although admittedly the digits are much more uniform to each other. I'll test how this holds up when I change training from MNIST to CelebA.

Now, let's take a look at the other results, namely for 1:1 trained, 2:3, 3:4, 4:5 and the dreaded 9:16 from last time and see how S2ID holds up this time:

[1:1 - 28x28](https://preview.redd.it/hfg133rxol9g1.png?width=2000&amp;format=png&amp;auto=webp&amp;s=b03a59cc5ee0b05803de88b5d1efe9e6d0a88c87)

[2:3 - 27x18](https://preview.redd.it/7fvas2rxol9g1.png?width=2000&amp;format=png&amp;auto=webp&amp;s=22ed0489be43b605510b5acccd22c362ba182cff)

[3:2 - 18x27](https://preview.redd.it/mrtj64rxol9g1.png?width=2000&amp;format=png&amp;auto=webp&amp;s=3b686da105f38671102690749311a47c0422d868)

[3:4 - 32x24](https://preview.redd.it/k5wrsfrxol9g1.png?width=2000&amp;format=png&amp;auto=webp&amp;s=6bc502fc1a97082edc7eca94c2e750c5601262a8)

[4:3 - 24x32](https://preview.redd.it/e069jwtxol9g1.png?width=2000&amp;format=png&amp;auto=webp&amp;s=11780e75214927390820b023c02997aefa816ea6)

[4:5 - 30x24](https://preview.redd.it/kth3tltxol9g1.png?width=2000&amp;format=png&amp;auto=webp&amp;s=a0177338e5184969d4a80392f76ad5de5ebf0391)

[5:4 - 24x30](https://preview.redd.it/3drv5grxol9g1.png?width=2000&amp;format=png&amp;auto=webp&amp;s=ddc1292978202dea98506d79c59380f869b14dac)

[9:16 - 32x18](https://preview.redd.it/gbcvvfrxol9g1.png?width=2000&amp;format=png&amp;auto=webp&amp;s=e8fbbdb37c02561574ce170b2ce3fde010ec649a)

[16:9 - 18x32](https://preview.redd.it/ay3hpfrxol9g1.png?width=2000&amp;format=png&amp;auto=webp&amp;s=58037c6283c592d2fe49f6576a568fe3347ebce9)

Like with the 1024x1024, the results are significantly better than in the last iteration. A lot less artifacts, even when we're really testing the limits with the 16:9 aspect ratio, as the coordinates become quite ugly in that scenario with the way the coordinate system works. Nevertheless, S2ID successfully seems to generalize: it applies a combination of a squish + crop whenever it has to, such that the key element of the image: the digit, doesn't actually change that much. Considering the fact that the model was trained on unaugmented data and still yields these results indicates great potential.

As last time, a quick look at double and quadruple the trained resolution. But unlike the last time, you'll see that this time around the results are far better cleaner and more accurate, at the expense of variety:

[Double Resolution - 56x56](https://preview.redd.it/288wgozpol9g1.png?width=2000&amp;format=png&amp;auto=webp&amp;s=742f9401d68305b59131deb93cbd3ac633975a08)

[Quarduple resolution - 128x128](https://preview.redd.it/d0p44qzpol9g1.png?width=800&amp;format=png&amp;auto=webp&amp;s=06411795c0525c9eb5058d0ecff7ed3e42251689)

For completion, here is the t-scrape loss. It's a little noisy, which suggest to me that I should use the very same gaussian noisifying coordinate jitter technique used for the positioning, but that's for the next iteration:

[T scrape loss, noisy but better than last time](https://preview.redd.it/wvkjc1ftol9g1.png?width=640&amp;format=png&amp;auto=webp&amp;s=fd2d587da70cae59b6dd2163e4d977553921f92f)

# How does S2ID work?

The previous post/explanation was a bit of an infodump, I'll try to explain it a bit clearer this time, especially considering that some redundant parts were removed/replaced, the architecture is a bit simpler now.

In short, as the goal of S2ID is to be a scale invariant model, it treats the data accordingly. The images, when fed into the model, are a fixed grid that represent a much more elegant underlying function that doesn't care about the grid nature. So our goal is to approach the data as such. First, each pixel's coordinates is calculated as an exact value from -0.5 to 0.5 along the x and y axis. Two values are obtained: the coordinate relative to the image, and the coordinate relative to the composition. The way that the coordinate relative to the composition works is that we inscribe the image and whatever aspect ratio it is into a 1:1 square, and then project the pixels of the image on to the square. This allows the model to learn composition, and not stretch it as the distance between the pixels is uniform. The second coordinate system, the one relative to the image, simply assigns all the image edges the respective +- 0.5, and then have a linspace assign the values along there. The gap between pixels varies, but the model now knows how far the pixel is from the edge. If we only used the first system of coordinates, the model would ace composition, but would simply crop out the subject if the aspect ratio changed. If we used only the second system of coordinates, the model would never crop, but then at the same time it would always just squish and squeeze the subject. It is with these two systems together that the model generalizes. Next up is probably the most important part of it all: and that is turning the image from pixel space into more or less a function. We do not use FFT or anything like that. Instead, we add gaussian noise to the coordinates with a dynamic standard deviation such that the model learns that the pixels isn't the data, it's just one of the many views of the data, and the model is being trained on other, alternative views that the data could have been. We effectively treat it like this: "If our coordinates are \[0.0, 0.1, 0.2, ...\], then what we really mean to say is that 0.1 is just the most likely coordinate of that pixel, but it could have been anything". Applying gaussian noise does exactly this: jitters around the pixel's coordinates, but not their values, as an alternative, valid view of the data. Afterwards, we calculate the position vector via RoPE, but we use increasing instead of decreasing frequencies. From there, we simply use transformer blocks with axial but without cross attention so that the model understands the composition, then transformer blocks with axial and cross attention so that the model can attend to the prompt, and then we de-compress this back to the number of color channels and predicts the epsilon noise. As a workflow, it looks like this:

1. Calculate the relative positioning coordinates for the each pixel in the image
2. Add random jitter to each positioning system
3. Turn the jittered coordinates into a per-pixel vector via fourier series, akin to RoPE, but we use ever-increasing frequencies instead
4. Concatenate the coordinate vector with the pixel's color values and pass though a single 1x1 convolution kernel to expand to d\_channels
5. Pass the latent through a series of encoder blocks: it's transformers on axial attention, but no cross attention so that the model understands composition first
6. Pass the attended latent though the decoder blocks that have axial and cross attention
7. Pass the fully attended latent through a 1x1 convolution kernel to create and predict the epsilon noise

This is obviously a simplification, and you can read the full code on the repository linked above if you want (although like I said before, forgive for the messy code, I'd like to get the architecture to a stable state first, and then do one massive refactor to clean everything up). The current architecture also heavily employs FiLM time modulation, dropouts, residual and skip connections, and the encoder/decoder block (just the names I picked) make it so that the model should in theory work like FLUX Kontext as well, as the model understands composition before the actual text conditioning implementation.

# What changed from the previous version?

In the [previous post](https://www.reddit.com/r/MachineLearning/comments/1puosfp/p_siid_a_scale_invariant_pixelspace_diffusion/?utm_source=share&amp;utm_medium=web3x&amp;utm_name=web3xcss&amp;utm_term=1&amp;utm_content=share_button), I asked for suggestions and improvements. One that stood out was by u/BigMrWeeb and u/cwkx to look into infinity diffusion. The core concept there is to model the underlying data as a function, and diffuse on the function, not the pixels. I read the paper, and while I can't say that I agree with the approach as compressing an image down to a certain fixed number of functions is not much different to learning it at a fixed resolution and then downscaling/upscaling accordingly; I must say that it has helped me understand/formalize the approach better, and it has helped me solve the key issue of artifacts. Namely:

* In the previous iteration, during training, each pixel got a fixed coordinate that would be then used for the positioning system. However, the coordinates are a continuous system, not discrete. So when training, the model didn't have any incentive to learn the continuous distribution. This time around, in order to force the model to understand the continuity, each pixel's coordinates are jittered. During training, to the true coordinate is added a random value, a sample from a gaussian distribution with a mean of 0 and a standard deviation of half the distance between the pixel and the adjacent pixel. The idea here being that now, the model is generalizing to a smooth interpolation between the pixels. A gaussian distribution was chosen after a quick test with a uniform, since gaussian naturally better represents the "uncertainty" of the value of each pixel, while uniform is effectively a nearest-exact. The sum of all the gaussian distributions is pretty close to 1, with light wobble, but I don't think that this should be a major issue. Point being, the model now learns the coordinate system as smooth and continuous rather than discrete, allowing it to generalize into aspect ratios/resolutions well beyond trained.
* With the coordinate system now being noisy, this means that we are no longer bound by the frequency count. Previously, I had to restrict the number of powers I could use, since beyond a certain point frequencies are indistinguishable from noise. However, this problem only makes sense when we're taking samples at fixed intervals. But with the added noise, we are not, we now have theoretical infinite accuracy. Thus, the new iteration was trained on a frequency well beyond what's usable for the simple 28x28 size. The highest frequency period is 128pi, and yet the model does not suffer. With the "gaussian blur" of the coordinates, the model is able to generalize and learn what those high frequencies mean, even though they don't actually exist in the training data. This also helps the model to diffuse at higher resolutions and make use of those higher frequencies to understand local details.
* In the previous iteration, I used pixel unshuffle to compress the height and width into color channels. I experienced artifacts as early as 9:16 aspect ratio where the latent height/width was double what was trained. I was able to pinpoint the culprit of this error, and that was the pixel unshuffle. The pixel unshuffle is not scale invariant, and thus it was removed, the model is working on the pixel space directly.
* With the pixel unshuffle removed, each token is now smaller by channel count, which is what allowed to decrease the parameter count down to 6.1M parameters. Furthermore, no new information is added by bicubic upscaling the image to 64x64, thus the model trains on 28x28 directly, and the gaussian coordinate jittering allows the model to generalize this data to a general function, the number of pixels you show to the image is only the amount of data you have, the accuracy of the function, nothing more.
* With everything changed, the model is now more friendly with CFG and eta, doesn't need it to be as high, although I couldn't be bothered experimenting around.

# Further improvements and suggestions

As mentioned, S2ID now diffuses in raw pixel space. This is both good and bad. From the good side, it's now truly scale invariant and the outputs are far cleaner. From the bad side, it takes longer to train. However, there are ways to mitigate it that I suppose are worth testing out:

* Using S2ID as a latent diffusion model, use a VAE to compress the height and width down. The FLUX/SDXL vae compresses the height and width by 8x, resulting in a latent size of 128 for 1024 size images. A sequence length of 128 is already far more manageable than the 1024 by 1024 images that I've showcased here since this current iteration is working in pixel space. VAEs aren't exactly scale invariant, but oh well, sacrifices must be made I suppose.
* Randomly drop out pixels/train in a smaller resolution. As mentioned before, the way that the gaussian noise is used, it forces the model to learn a general distribution and function to the data, not to just memorize coordinates. The fact that it learnt 28x28 data but has learnt to render good images at massive resolutions, or even at double resolutions, seems to suggest that you can simply feed in a lower resolution verison of the image and still get decent data. I will test this theory out by training on 14x14 MNIST. However, this won't speed up inference time like VAE will, but I suppose that both of these approaches can be used. As I say this now, talking about training on 14x14, this reminds me of how you can de-blur a pixelated video as long as the camera is moving. Same thing here? Just blur the digits properly instead of blindly downscaling, i.e. upscale via bicubic, jitter, downscale, and then feed that into the model. Seems reasonable.
* Replace the MHA attention with FlashAttention or Linear Transformers. Honestly I don't know what I think about this, feels like a patch rather than an improvement, but it certainly is an option.
* Words cannot describe how unfathomably slow it is to diffuse big resolutions, this is like the number 1 priority now. On the bright side, they require SIGNIFICANTLY less diffusion steps. Less than 10 is enough.

Now with that being said, I'm open to critique, suggestions and questions. Like I said before, please forgive the messy state of the code, I hope you can understand my disinterest in cleaning it up when the architecture is not yet finalized. Frankly I would not recommend running the current ugly code anyway as I'm likely to make a bunch of changes and improvements in the near future; although I do understand how this looks more shady. I hope you can understand my standpoint.

Kind regards.


Top 3 comments:

Comment 1:
Author: Shizuka_Kuze
Score: 37
Created UTC: 1766781109.0
Comment: The results are nice on the surface, but could just be overfitting, or more probably, deceptive. I also really am not sure I understand how what you’re doing is supposed to make it “model the underlying data in the image” and not the resolution.

Firstly, by deceptive I mean that MNIST is one of the datasets that is not impacted by resolution while real world problems absolutely are. For instance the individual hairs in a shampoo infomercial are not visible in the low resolution domain while in the high resolution domain they are rather prominent. 

With MNIST you are really and truly interpolating pixels between different resolutions while in other approaches you’d need to extrapolate information that does not exist. From an information theory perspective the distribution between different MNIST images at different resolutions is essentially the same. With others it is different. This is especially questionable given your Gaussian noise adding thingy that’s basically just a low pass filter which would filter out higher frequency information like textures. This is not an issue on MNIST, and it might even smooth the digits, but I suspect it would destroy textures in the wild. You could try penalizing differences in the derivative of the image function instead and it might help preserve texture better if you find it does not work on real datasets maybe?

The issues people face with resolution invariance really isn’t what you’re solving (scale invariance) but rather texture invariance as I described. Especially on MNIST there is practically no information loss. There’s no textures to lose anyways, and the scale really doesn’t matter. Compare to aerial view of a city. A group of eight  by eight pixels might contain both a car and a person, and you can’t simply smooth it out. You might even need contextual global information to figure out it what it is, which I don’t think the model has. 

To demonstrate the feasibility of this approach, I would suggest training on cats, dogs, trucks, cars, etc and seeing how the results compare. If you require, I can help you with finding data and send baseline implementation models for you to compare against.

Also I really don’t mean to be rude, but I fail to see how this differs (in terms of goal) from latent diffusion with a multi-resolution VAE or just using continuous latent space. If your goal is just to learn the underlying function, why not just learn the underlying latent? It’s also much cheaper computationally speaking. You’re also working in pixel space. As you’ve already said, this will destroy your computational efficiency. Assuming you’re using standard transformers you have O(N^2) complexity which is insanely inefficient on 1024x1024 images. 

I know you said you’re worried about losing scale invariance but I’m just not convinced your model is even close scale invariant on non-MNIST datasets. Your high resolution images kinda look like they might suffer textures aliasing of some like low-pass cutoff issue. They are very smooth and on mobile look almost weirdly feathered?

Additionally, using 1x1 convolutions and the way you’re applying axial attention are red flags. Using 1x1 convolutions as you are puts the burden on the attention mechanism to keep global context… but the way you’re using axial attention is odd. Axial attention normally would rely on a well-defined row and column information structure, but if I understand correctly then I just don’t understand how if you use weird resolutions the model won’t freak out if the rows and columns become arbitrary EX (4:1 resolution) or (1:4.)

It’s definitely an interesting idea and I’ll follow along, but I’m extremely skeptical.

I also believe similar work also exists such as:

https://arxiv.org/abs/2012.09161

https://arxiv.org/abs/1904.00284

Comment 2:
Author: MoridinB
Score: 3
Created UTC: 1766781306.0
Comment: I can't say I understand the technique fully. I'm very interested in this and would love to spend some more attention to your technique and code.

One question I had is, wouldn't it be more feasible to apply this technique not on the diffusion process but rather the VAE? What I mean is use your process to learn a scale-invariant latent. And then apply the diffusion process on said latent before decoding?

I may be fundamentally misunderstanding your technique, so please excuse me if that's the case. Perhaps I can offer some better insight once I've examined more thoroughly.

Edit: Because I received a comment saying my original comment is not very clear. My point is not just to add a VAE to the setup and operate on a latent space. Rather, my point is to use the coordinate-aware learning on a VAE rather than a diffusion model. The key is that VAE don't require a large architecture, so learning a scale-invariant latent code and then diffusing would alleviate the load from the diffusing process onto the smaller VAE encoder and decoder.

Comment 3:
Author: Regalme
Score: 2
Created UTC: 1766781753.0
Comment: I’m gonna need a tldr but I appreciate the effort. Here will dig in with more time