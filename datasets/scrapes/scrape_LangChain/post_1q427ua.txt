Post Title: Added a validation layer between my SQL agent and the database - sharing in case useful
Author: Educational_Poet_862
Score: 7
URL: https://www.reddit.com/r/LangChain/comments/1q427ua/added_a_validation_layer_between_my_sql_agent_and/
Number of comments: 2
Created UTC: 1767562158.0

Post Content:
Been building a LangChain agent that queries a Postgres database. Model is smart enough not to do anything malicious, but I wanted:

1. **Explicit scope control** - define exactly which tables the agent can touch
2. **Observability** - log when the agent tries something outside its lane
3. **Another layer** - defense in depth alongside read-only DB creds

Built a small validation layer:

    from langchain_community.utilities import SQLDatabase
    from proxql import Validator

    db = SQLDatabase.from_uri("postgresql://readonly@localhost/mydb")

    validator = Validator(
        mode="read_only",
        allowed_tables=["products", "orders", "categories"]
    )

    def run_query(query: str) -&gt; str:
        check = validator.validate(query)
        if not check.is_safe:
            logger.warning(f"Out of scope: {query} - {check.reason}")
            return f"Query not allowed: {check.reason}"
        return db.run(query)

**What it does:**

- Table allowlist - hard boundary on which tables are accessible (catches subqueries, CTEs, JOINs)
- Statement filtering - read_only mode only allows SELECT
- Dialect-aware - uses sqlglot for Postgres/MySQL/Snowflake support

**What it doesn't do:**

- Replace proper DB permissions (still use a read-only user)
- Prevent expensive queries
- Protect against a determined attacker - it's a guardrail for mistakes, not security

Mostly useful for observability. When a query gets blocked, I review what the agent was trying to do - usually means my prompts need tuning.

---

pip install proxql

GitHub: https://github.com/zeredbaron/proxql

---

Curious what others are doing for agent scope control. Are you just trusting the model + DB permissions, or adding validation layers?


Top 2 comments:

Comment 1:
Author: rkpandey20
Score: 1
Created UTC: 1767602610.0
Comment: I see a lot of people building protection layer to process action described by the agent. Like in this case, sql generated by agent. 
Just wondering if age old way of creating indirection where you create a grammar equivalent to sql that you want to support, is out of fashion these days. 

Comment 2:
Author: pbalIII
Score: 1
Created UTC: 1767672985.0
Comment: Most SQL agents ship the query straight to the DB and pray. The validation layer is where you catch the expensive mistakes... malformed joins, accidental mutations, queries that'd time out in prod.

LangChain has a built-in sql_db_query_checker tool but layering your own checks (schema validation, read-only enforcement, cost estimation) gives you way more control. Curious what checks you're running in yours.